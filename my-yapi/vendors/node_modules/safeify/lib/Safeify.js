"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = __importStar(require("os"));
const childProcess = __importStar(require("child_process"));
const CGroups_1 = require("./CGroups");
const Worker_1 = require("./Worker");
const MessageType_1 = require("./MessageType");
const Script_1 = require("./Script");
const WorkerState_1 = require("./WorkerState");
const { isFunction, isNumber, getByPath } = require("ntils");
const log = require("debug")("safeify");
const defaultSandbox = Object.create(null);
const defaultOptions = {
    timeout: 1000,
    asyncTimeout: 30000,
    workers: os.cpus().length,
    cpuQuota: 0.5,
    memoryQuota: 500
};
const runnerFile = require.resolve("./runner");
const childExecArgv = (process.execArgv || []).map(flag => flag.includes("--inspect") ? "--inspect=0" : flag);
const instances = [];
process.once("exit", () => {
    instances.forEach(instance => instance.destroy());
});
class Safeify {
    constructor(opts = {}) {
        this.options = {};
        this.workers = [];
        this.pendingScripts = [];
        this.cgroups = null;
        this.inited = false;
        this.presets = [];
        this.destroy = () => {
            const index = instances.indexOf(this);
            if (index > -1)
                instances.splice(index, 1);
            this.workers.forEach(worker => this.destroyWorker(worker));
            this.workers = [];
        };
        this.distory = () => {
            console.warn("deprecated:", `Please use 'destroy' instead of 'distory'`);
            return this.destroy();
        };
        this.onWorkerMessage = (message) => {
            switch (message.type) {
                case MessageType_1.MessageType.done:
                    return this.onWorkerDone(message);
                case MessageType_1.MessageType.call:
                    return this.onWokerCall(message);
            }
        };
        this.alignmentWorker = async () => {
            const healthyWorkers = [];
            const unhealthyWorkers = [];
            this.workers.forEach(item => {
                if (item.state === WorkerState_1.WorkerState.healthy && item.process.connected) {
                    healthyWorkers.push(item);
                }
                else {
                    unhealthyWorkers.push(item);
                }
            });
            this.workers = healthyWorkers;
            await this.createWorkers();
            if (this.pendingScripts.length > 0)
                this.execute();
            unhealthyWorkers.forEach(item => this.destroyWorker(item));
        };
        this.onWorkerDisconnect = async () => {
            log("onWorkerDisconnect", "pendingScripts", this.pendingScripts.length);
            await this.alignmentWorker();
        };
        this.onScriptAsyncTimeout = (worker, script) => {
            worker.runningScripts.forEach(item => {
                if (item.id === script.id)
                    return;
                this.pendingScripts.unshift(item.stop());
            });
            script.error = "Script execution timed out.";
            this.handleScriptDone(worker, script, true);
        };
        instances.push(this);
        opts = this.normalize(opts);
        this.options = Object.assign(Object.assign({}, defaultOptions), opts);
    }
    normalize(opts) {
        opts = Object.assign({}, opts);
        if (!isNumber(opts.workers))
            opts.workers = opts.quantity;
        if (!isNumber(opts.workers))
            opts.workers = defaultOptions.workers;
        if (opts.workers < 2)
            opts.workers = 2;
        if (!isNumber(opts.timeout))
            opts.timeout = 1000;
        if (!isNumber(opts.asyncTimeout) || opts.asyncTimeout < opts.timeout) {
            opts.asyncTimeout = opts.timeout * 3;
        }
        return opts;
    }
    async init() {
        if (this.inited)
            return;
        this.inited = true;
        const { unrestricted } = this.options;
        if (!unrestricted)
            await this.createControlGroup();
        await this.createWorkers();
    }
    destroyWorker(worker) {
        worker.state = WorkerState_1.WorkerState.unhealthy;
        worker.runningScripts.forEach(script => script.stop());
        worker.process.removeAllListeners("message");
        worker.process.removeAllListeners("disconnect");
        if (worker.process.connected)
            worker.process.disconnect();
        if (!worker.process.killed)
            worker.process.kill("SIGKILL");
    }
    get workerTotal() {
        return this.workers.length;
    }
    get pendingTotal() {
        return this.pendingScripts.length;
    }
    get runningTotal() {
        return this.workers.reduce((count, worker) => {
            return count + worker.runningScripts.length;
        }, 0);
    }
    async onWokerCall(message) {
        const { call, pid, scriptId } = message;
        if (!call)
            return;
        const worker = this.workers.find(item => item.process.pid === pid);
        if (!worker)
            return;
        const script = worker.runningScripts.find(item => item.id === scriptId);
        if (!script)
            return;
        try {
            const breadcrumb = call.name.split(".");
            const name = breadcrumb.pop();
            const context = getByPath(script.sandbox, breadcrumb) || defaultSandbox;
            call.result = await context[name](...call.args);
        }
        catch (err) {
            call.error = err.message;
        }
        const type = MessageType_1.MessageType.ret;
        worker.process.send({ type, call });
    }
    onWorkerDone(message) {
        const { pid, script } = message;
        const worker = this.workers.find(item => item.process.pid === pid);
        this.handleScriptDone(worker, script, false);
    }
    async handleScriptDone(worker, script, kill) {
        if (!worker || !script)
            return;
        if (kill) {
            worker.state = WorkerState_1.WorkerState.unhealthy;
            await this.alignmentWorker();
        }
        else {
            worker.stats--;
        }
        if (this.pendingScripts.length > 0)
            this.execute();
        this.handleScriptResult(worker, script);
    }
    handleScriptResult(worker, script) {
        const runningIndex = worker.runningScripts.findIndex(item => item.id === script.id);
        if (runningIndex < 0)
            return;
        const runningScript = worker.runningScripts.splice(runningIndex, 1)[0];
        if (!runningScript)
            return;
        runningScript.stop();
        if (script.error) {
            runningScript.reject(new Error(script.error));
            log("onWorkerDone error", script.id, script.error);
        }
        else {
            runningScript.resolve(script.result);
            log("onWorkerDone result", script.id, script.result);
        }
    }
    createControlGroup() {
        this.cgroups = new CGroups_1.CGroups("safeify");
        const { cpuQuota, memoryQuota } = this.options;
        return this.cgroups.set({
            cpu: { cfs_quota_us: 100000 * cpuQuota },
            memory: { limit_in_bytes: 1048576 * memoryQuota }
        });
    }
    async createWorker() {
        const { unrestricted } = this.options;
        const workerProcess = childProcess.fork(runnerFile, [], {
            execArgv: childExecArgv
        });
        if (!unrestricted)
            await this.cgroups.addProcess(workerProcess.pid);
        return new Promise(resolve => {
            workerProcess.once("message", (message) => {
                if (!message || message.type !== MessageType_1.MessageType.ready)
                    return;
                workerProcess.on("message", this.onWorkerMessage);
                workerProcess.on("disconnect", this.onWorkerDisconnect);
                resolve(new Worker_1.Worker(workerProcess));
            });
        });
    }
    get healthyWorkers() {
        return this.workers.filter(worker => worker.process.connected && worker.state === WorkerState_1.WorkerState.healthy);
    }
    async createWorkers() {
        const num = this.options.workers - this.healthyWorkers.length;
        const workers = [];
        for (let i = 0; i < num; i++) {
            workers.push((async () => {
                const worker = await this.createWorker();
                this.workers.push(worker);
                return worker;
            })());
        }
        return Promise.all(workers);
    }
    execute() {
        const worker = this.options.greedy === false
            ? this.healthyWorkers.find(w => w.stats < 1)
            : this.healthyWorkers.sort((a, b) => a.stats - b.stats)[0];
        if (!worker)
            return;
        log("execute pid", worker.process.pid);
        const script = this.pendingScripts.shift();
        if (!script)
            return;
        worker.stats++;
        worker.runningScripts.push(script);
        log("execute code", script.code);
        script.start(() => this.onScriptAsyncTimeout(worker, script));
        worker.process.send({ type: MessageType_1.MessageType.run, script });
    }
    toCode(code) {
        if (!code)
            return ";";
        if (isFunction(code)) {
            const result = /\{([\s\S]*)\}/.exec(code.toString());
            return result[1] || "";
        }
        else {
            return code.toString();
        }
    }
    preset(code) {
        this.presets.push(this.toCode(code));
    }
    async run(code, sandbox) {
        await this.init();
        code = [...this.presets, this.toCode(code), os.EOL].join(";");
        log("run", code);
        const { timeout, asyncTimeout, unsafe } = this.options;
        const script = new Script_1.Script({ code, timeout, asyncTimeout, sandbox, unsafe });
        this.pendingScripts.push(script);
        this.execute();
        return script.defer;
    }
}
exports.Safeify = Safeify;
//# sourceMappingURL=Safeify.js.map